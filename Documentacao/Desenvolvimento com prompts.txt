üõ†Ô∏è Instru√ß√µes de Uso
Copie e cole os prompts na ordem abaixo.
Use o Claude 3.5 Sonnet (ou Opus) para a gera√ß√£o de c√≥digo complexo (Backend, SQL, L√≥gica) e o Gemini 1.5 Pro para revis√£o de arquitetura ou gera√ß√£o de documenta√ß√£o, devido √† janela de contexto maior.
Regra de Ouro: Se a IA gerar c√≥digo incompleto (ex: ...rest of code), pe√ßa explicitamente: "Continue exatamente de onde parou e complete o c√≥digo."

üìÇ Passo 0: O Contexto Mestre (Use sempre)
Antes de iniciar qualquer prompt, copie e cole este bloco de contexto para que a IA "encarne" o Engenheiro Chefe do projeto.
CONTEXTO DO PROJETO: Estamos construindo o "Cortex Brasil", um agente financeiro pessoal via WhatsApp.
Arquitetura: Python (FastAPI), PostgreSQL (Local com RLS), Docker. - Hardware: Execu√ß√£o local em GPU NVIDIA RTX 5080 (16GB VRAM). - IA: LLM Qwen 2.5-7B (via vLLM) e Faster-Whisper para √°udio. - Seguran√ßa: Dados isolados por Row-Level Security (RLS) e criptografia AES-256. - Objetivo: Receber √°udios/textos, extrair transa√ß√µes financeiras (JSON), salvar no DB e gerar insights (Nudges).
+4
Restri√ß√£o: C√≥digo deve ser production-ready, tipado (Type Hints), documentado e seguir princ√≠pios SOLID.

üèóÔ∏è Fase 1: Infraestrutura de Dados (A Funda√ß√£o)
O objetivo √© criar o banco de dados blindado com isolamento de usu√°rios (Multi-tenancy via RLS).
Prompt 1: Schema SQL e Seguran√ßa (PostgreSQL)
Plaintext
Atue como um Arquiteto de Banco de Dados S√™nior. Preciso do script SQL DDL completo (`init.sql`) para o PostgreSQL 16.

Requisitos T√©cnicos Baseados na Especifica√ß√£o:
1. Habilite as extens√µes: `pgcrypto` (para criptografia) e `vector` (para mem√≥ria sem√¢ntica)[cite: 69, 92].
2. Crie a tabela `users` e a tabela `transactions`.
3. Implemente Row-Level Security (RLS) mandat√≥rio:
   - Toda tabela deve ter uma coluna `tenant_id` (UUID).
   - Crie a pol√≠tica (POLICY) que for√ßa o isolamento: `USING (tenant_id = current_setting('app.current_tenant')::uuid)`[cite: 62, 63].
4. A tabela `transactions` deve ter campos criptografados para `description` usando PGP_SYM_ENCRYPT[cite: 69].
5. Crie √≠ndices otimizados, garantindo que `tenant_id` seja sempre a primeira coluna do √≠ndice composto para performance do RLS[cite: 344].

Gere o SQL completo, comentado e pronto para rodar.

üß† Fase 2: O Motor de IA (O C√©rebro)
Aqui configuramos o cliente que fala com a GPU. Precisamos gerenciar a VRAM com cuidado.
Prompt 2: Cliente vLLM e Engenharia de Prompt
Plaintext
Atue como um Engenheiro de Machine Learning. Crie um m√≥dulo Python (`ai_engine.py`) para interagir com o modelo Qwen 2.5-7B rodando no vLLM.

Requisitos:
1. Use a biblioteca `openai` (o vLLM √© compat√≠vel com a API da OpenAI).
2. Crie uma classe `FinancialExtractor`.
3. Implemente um m√©todo `extract_transaction(text: str)` que recebe um texto informal e retorna um objeto JSON validado pelo Pydantic.
4. O System Prompt deve ser robusto para extrair: valor, moeda, categoria, m√©todo de pagamento e recorr√™ncia[cite: 38].
5. Implemente l√≥gica de retry caso o JSON venha malformado (Output Parsers).
6. Configure o cliente para usar `max_tokens` limitados e temperatura baixa (0.1) para precis√£o.

Observa√ß√£o cr√≠tica: O hardware √© uma RTX 5080. O c√≥digo deve estar preparado para lidar com timeouts se a GPU estiver ocupada com processamento de √°udio[cite: 320].

Gere o c√≥digo Python completo com as classes Pydantic.
Prompt 3: Processamento de √Åudio (Whisper)
Plaintext
Atue como um Engenheiro de Processamento de Sinais. Crie o m√≥dulo `audio_processor.py`.

Requisitos:
1. Utilize a biblioteca `faster-whisper` com o modelo 'large-v3'[cite: 257].
2. Implemente uma fun√ß√£o `transcribe_audio(file_path: str) -> str`.
3. Implemente OTIMIZA√á√ÉO DE VRAM: A fun√ß√£o deve carregar o modelo na GPU apenas no momento do uso e descarreg√°-lo (ou mover para CPU) ap√≥s o uso, pois a RTX 5080 tem apenas 16GB e divide espa√ßo com o LLM[cite: 260].
4. Configure para usar precis√£o `float16` se dispon√≠vel.
5. Adicione tratamento de erro para arquivos corrompidos.

Gere o c√≥digo completo.

üîå Fase 3: Backend e API (O Corpo)
Conectar o WhatsApp (Webhook) ao C√©rebro (IA).
Prompt 4: Estrutura FastAPI e Webhook Meta
Plaintext
Atue como um Engenheiro Backend S√™nior (Python). Crie o arquivo principal `main.py` usando FastAPI.

Requisitos do Endpoint `/webhook`:
1. Valida√ß√£o de Seguran√ßa: Implemente a verifica√ß√£o da assinatura HMAC-SHA256 (X-Hub-Signature-256) da Meta para garantir que a requisi√ß√£o √© leg√≠tima[cite: 116, 282].
2. Idempot√™ncia: Use Redis (ou um dict em mem√≥ria para este MVP) para verificar se o `wamid` (Message ID) j√° foi processado, evitando duplicidade de gastos[cite: 325].
3. Processamento Ass√≠ncrono: O endpoint deve apenas receber a mensagem, colocar em uma `asyncio.Queue` (BackgroundTasks) e retornar 200 OK imediatamente para evitar timeout do WhatsApp[cite: 316].
4. Crie um `worker` consumidor que l√™ a fila e chama os m√≥dulos de IA criados nos passos anteriores.

Gere o c√≥digo completo do FastAPI, incluindo a inje√ß√£o de depend√™ncia para conex√£o com o Banco de Dados.
Prompt 5: Middleware de Seguran√ßa RLS
Plaintext
Para garantir a privacidade absoluta descrita no projeto, preciso de um Middleware para o FastAPI (`middleware.py`) ou uma depend√™ncia de sess√£o (`deps.py`).

Requisitos:
1. Ao receber uma requisi√ß√£o, identifique o usu√°rio (pelo n√∫mero de telefone do WhatsApp).
2. Recupere o `tenant_id` desse usu√°rio no banco.
3. Antes de executar qualquer query, execute o comando SQL: `SET app.current_tenant = 'UUID_DO_USUARIO'` na sess√£o do banco de dados[cite: 57, 63].
4. Isso garante que o RLS do PostgreSQL funcione.

Gere o c√≥digo de integra√ß√£o entre o SQLAlchemy (ou driver asyncpg) e essa l√≥gica de sess√£o.

üî¢ Fase 4: L√≥gica Financeira (A Raz√£o)
Prompt 6: Calculadora de Parcelamento e Amortiza√ß√£o
Plaintext
Atue como um Matem√°tico Financeiro e Desenvolvedor Python. Crie o m√≥dulo `finance_logic.py`.

Requisitos:
1. Implemente a fun√ß√£o de proje√ß√£o de parcelas. Se o input for "iPhone em 12x de 500", o sistema deve gerar 12 registros futuros no banco[cite: 77].
2. Implemente a fun√ß√£o de Amortiza√ß√£o (Tabela Price) conforme a f√≥rmula matem√°tica: PMT = PV * i / (1 - (1+i)^-n)[cite: 79].
3. O c√≥digo deve ser capaz de calcular o desconto (valor presente) se o usu√°rio antecipar parcelas.

Gere o c√≥digo Python com tipagem forte e testes unit√°rios b√°sicos embutidos.

üê≥ Fase 5: Orquestra√ß√£o e Deploy (A Entrega)
Prompt 7: Docker Compose e Otimiza√ß√£o GPU
Plaintext
Atue como um Engenheiro DevOps Especialista em NVIDIA. Crie o arquivo `docker-compose.yml` para subir toda a stack.

Servi√ßos necess√°rios:
1. `db`: PostgreSQL 16 (imagem oficial).
2. `app`: O container da aplica√ß√£o FastAPI (Dockerfile a ser gerado).
3. `vllm`: Container oficial do vLLM para servir o modelo Qwen.
4. `cloudflared`: Container para criar o t√∫nel seguro para o WhatsApp[cite: 74].

Requisitos Cr√≠ticos de Hardware:
- Configure o servi√ßo `app` e `vllm` para ter acesso √† GPU (runtime: nvidia).
- Defina vari√°veis de ambiente para limitar o uso de mem√≥ria do vLLM (`gpu-memory-utilization`) para deixar espa√ßo para o Whisper[cite: 256].
- Configure volumes persistentes para o Postgres e modelos de IA (para n√£o baixar toda vez).

Gere o docker-compose.yml completo e o Dockerfile para o backend.

üìã Pr√≥ximo Passo Sugerido para o Usu√°rio
Ap√≥s rodar esses prompts e salvar os arquivos, voc√™ ter√° a base completa do c√≥digo. O passo final que a IA n√£o pode fazer fisicamente √©:
Comprar e instalar a RTX 5080.
Configurar o Cloudflare Tunnel com seu dom√≠nio.
Configurar a conta no Meta for Developers para pegar o Token e apontar para o URL do t√∫nel.
